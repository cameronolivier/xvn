# Task M9.6: Installation Conflict Detection

## Overview

Detect when multiple xvn installations exist (npm, Homebrew, Cargo) and warn users to prevent conflicts and confusion.

**Approach:**
- Detect installations during `xvn init` or `xvn setup`
- Store conflict state in `~/.xvn/conflict_warning` file
- Show warning on every `xvn activate` until resolved
- Clear warning when only one installation remains

---

## User Experience

### During xvn init/setup

```bash
$ xvn init

⚠️  Multiple xvn installations detected:
  - npm global package (@olvrcc/xvn) at /Users/cam/.nvm/versions/node/v20.19.5/bin/xvn
  - Homebrew (brew install xvn) at /opt/homebrew/bin/xvn

This may cause conflicts. We recommend keeping only one installation.

? Which installation would you like to keep?
  › npm global package (@olvrcc/xvn)
    Homebrew (brew install xvn)

To remove the other installation:
  brew uninstall xvn
```

### During xvn activate (when conflict exists)

```bash
$ cd ~/my-project
⚠️  Multiple xvn installations detected. Run 'xvn init' to resolve.
Switching to Node.js v18.20.0 (from .nvmrc)
```

---

## Implementation Design

### 1. Detection Logic

```rust
// src/installation_detector.rs

use std::path::PathBuf;

#[derive(Debug, Clone, PartialEq)]
pub enum InstallMethod {
    Npm,
    Homebrew,
    Cargo,
}

impl InstallMethod {
    pub fn description(&self) -> &str {
        match self {
            Self::Npm => "npm global package (@olvrcc/xvn)",
            Self::Homebrew => "Homebrew (brew install xvn)",
            Self::Cargo => "Cargo (cargo install)",
        }
    }

    pub fn uninstall_command(&self) -> &str {
        match self {
            Self::Npm => "npm uninstall -g @olvrcc/xvn",
            Self::Homebrew => "brew uninstall xvn",
            Self::Cargo => "cargo uninstall xvn",
        }
    }

    pub fn binary_path_contains(&self) -> &str {
        match self {
            Self::Npm => "node_modules",
            Self::Homebrew => "/Cellar/xvn",
            Self::Cargo => "/.cargo/bin",
        }
    }
}

pub struct InstallationDetector;

impl InstallationDetector {
    /// Detect all xvn installations in PATH
    pub fn detect_all() -> Vec<(InstallMethod, PathBuf)> {
        let mut installations = vec![];

        // Get all xvn binaries in PATH
        if let Ok(paths) = which::which_all("xvn") {
            for path in paths {
                let path_str = path.to_string_lossy();

                // Skip our own symlink installation
                if path_str.contains("/.xvn/bin/xvn") {
                    continue;
                }

                // Detect installation method
                if path_str.contains("node_modules") {
                    installations.push((InstallMethod::Npm, path));
                } else if path_str.contains("/Cellar/xvn") || path_str.contains("/opt/homebrew") {
                    installations.push((InstallMethod::Homebrew, path));
                } else if path_str.contains("/.cargo/bin") {
                    installations.push((InstallMethod::Cargo, path));
                }
            }
        }

        installations
    }

    /// Check if conflicts exist (more than one installation)
    pub fn has_conflicts() -> bool {
        Self::detect_all().len() > 1
    }

    /// Get the conflict warning file path
    fn conflict_file_path() -> PathBuf {
        dirs::home_dir()
            .expect("Could not determine home directory")
            .join(".xvn")
            .join("conflict_warning")
    }

    /// Mark that conflicts exist (create warning file)
    pub fn mark_conflict() {
        if Self::has_conflicts() {
            let path = Self::conflict_file_path();
            std::fs::create_dir_all(path.parent().unwrap()).ok();
            std::fs::write(path, "").ok();
        }
    }

    /// Clear conflict warning (delete warning file)
    pub fn clear_conflict() {
        let path = Self::conflict_file_path();
        std::fs::remove_file(path).ok();
    }

    /// Check if conflict warning should be shown
    pub fn should_warn() -> bool {
        Self::conflict_file_path().exists()
    }
}
```

### 2. Integration in init/setup Command

```rust
// src/commands/init.rs (or setup.rs)

use crate::installation_detector::{InstallationDetector, InstallMethod};
use inquire::Select;

pub fn run_init() -> Result<()> {
    // ... existing init logic ...

    // Check for multiple installations
    let installations = InstallationDetector::detect_all();

    if installations.len() > 1 {
        show_conflict_warning(&installations)?;
    }

    // ... rest of init logic ...

    Ok(())
}

fn show_conflict_warning(installations: &[(InstallMethod, PathBuf)]) -> Result<()> {
    use owo_colors::OwoColorize;

    println!();
    println!("  {} {}", "⚠️".yellow(), "Multiple xvn installations detected:".yellow().bold());
    println!();

    for (method, path) in installations {
        println!("  - {} at {}", method.description(), path.display().dimmed());
    }

    println!();
    println!("  This may cause conflicts. We recommend keeping only one installation.");
    println!();

    let choices: Vec<String> = installations
        .iter()
        .map(|(method, _)| method.description().to_string())
        .collect();

    let selection = Select::new("Which installation would you like to keep?", choices)
        .prompt()?;

    // Find the methods to remove
    let methods_to_remove: Vec<&InstallMethod> = installations
        .iter()
        .filter(|(method, _)| method.description() != selection)
        .map(|(method, _)| method)
        .collect();

    if !methods_to_remove.is_empty() {
        println!();
        println!("  To remove the other installation(s):");
        for method in methods_to_remove {
            println!("    {}", method.uninstall_command().cyan());
        }
    }

    // Mark conflict so we can warn on future activations
    InstallationDetector::mark_conflict();

    println!();

    Ok(())
}
```

### 3. Integration in activate Command

```rust
// src/commands/activate.rs

pub fn activate(path: Option<PathBuf>) -> Result<()> {
    // Check for conflict warning at the start
    if InstallationDetector::should_warn() {
        // Re-check if conflicts still exist
        if InstallationDetector::has_conflicts() {
            use owo_colors::OwoColorize;
            eprintln!(
                "{}",
                "⚠️  Multiple xvn installations detected. Run 'xvn init' to resolve.".yellow()
            );
        } else {
            // Conflicts resolved, clear the warning
            InstallationDetector::clear_conflict();
        }
    }

    // ... rest of activation logic ...

    Ok(())
}
```

### 4. Integration in install.js (npm)

```javascript
// install.js

const fs = require('fs');
const path = require('path');

// ... existing installation logic ...

// After successful installation, check for conflicts
function checkForConflicts() {
    const xvnDir = path.join(require('os').homedir(), '.xvn');
    const conflictFile = path.join(xvnDir, 'conflict_warning');

    // Mark that we should check for conflicts on next run
    // (we can't detect Homebrew from here, so let init do it)
    try {
        fs.mkdirSync(xvnDir, { recursive: true });
        fs.writeFileSync(conflictFile, '');
    } catch (err) {
        // Ignore errors, this is just a hint
    }
}

// Call after installation
checkForConflicts();
```

---

## File Changes

### New Files

- `src/installation_detector.rs` - Detection logic
- `spec/milestone-9/M9.6_CONFLICT_DETECTION.md` - This file

### Modified Files

- `src/lib.rs` - Export `installation_detector` module
- `src/commands/init.rs` - Add conflict detection
- `src/commands/setup.rs` - Add conflict detection
- `src/commands/activate.rs` - Show warning if conflicts exist
- `install.js` - Mark for conflict check

---

## Testing

### Manual Testing

```bash
# 1. Install via npm
npm install -g @olvrcc/xvn

# 2. Install via Homebrew
brew tap cameronolivier/xvn
brew install xvn

# 3. Run init
xvn init
# Should detect both installations and prompt

# 4. Try activate
cd ~/some-project
xvn activate .
# Should show warning

# 5. Uninstall one
npm uninstall -g @olvrcc/xvn

# 6. Try activate again
xvn activate .
# Warning should clear automatically
```

### Test Cases

- [x] Detect npm installation
- [x] Detect Homebrew installation
- [x] Detect Cargo installation
- [x] Detect multiple installations
- [x] Show warning in init/setup
- [x] Store conflict state
- [x] Show warning on activate
- [x] Clear warning when resolved
- [x] Don't warn for single installation
- [x] Ignore ~/.xvn/bin/xvn symlink

---

## Dependencies

- **Requires:** Milestone 9.1-9.3 complete (Homebrew distribution working)
- **Enables:** Clean user experience when switching between installation methods

---

## Success Criteria

- ✅ Detects npm, Homebrew, and Cargo installations (COMPLETED)
- ✅ Warns user during init/setup (COMPLETED)
- ✅ Shows persistent warning on activate (COMPLETED)
- ✅ Warning clears when conflicts resolved (COMPLETED)
- ✅ No false positives (ignores ~/.xvn/bin/xvn) (COMPLETED)
- ✅ User understands how to resolve conflicts (COMPLETED)

**Status: COMPLETED** (2025-10-12)

---

## Timeline

**Estimated Time:** 2-3 hours

- Detection logic: 1 hour
- Integration in commands: 1 hour
- Testing: 1 hour

---

## Notes

### Why Store Conflict State?

Instead of checking for conflicts on every `xvn activate`, we:
1. Check during `init/setup` (when user is setting up)
2. Store a flag file if conflicts exist
3. Show warning on `activate` only if flag exists
4. Re-check and clear flag when conflicts are resolved

This is more efficient and avoids unnecessary `which` calls.

### Future Enhancements

- Auto-detect preferred installation based on which was run first
- Option to silence warning: `xvn conflict --ignore`
- More detailed conflict resolution wizard
- Detect version mismatches between installations
