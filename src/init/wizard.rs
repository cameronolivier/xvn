use crate::config::{AutoInstallMode, Config};
use crate::init::detection::{detect_shell, detect_version_managers, get_profile_path};
use crate::init::prompts::{self, ConfigSummary};
use crate::output;
use crate::setup::shell_detection::Shell;
use anyhow::{Context, Result};
use dirs::home_dir;

/// Wizard state - collects configuration through steps
#[derive(Debug, Clone)]
pub struct WizardState {
    pub shell: Option<Shell>,
    pub plugins: Vec<String>,
    pub auto_install: AutoInstallMode,
    pub version_files: Vec<String>,
}

impl WizardState {
    /// Create new wizard state with defaults
    pub fn new() -> Self {
        Self {
            shell: None,
            plugins: Vec::new(),
            auto_install: AutoInstallMode::Prompt,
            version_files: vec![".nvmrc".to_string(), ".node-version".to_string()],
        }
    }

    /// Convert wizard state to Config
    pub fn to_config(&self) -> Result<Config> {
        Ok(Config {
            plugins: self.plugins.clone(),
            auto_install: self.auto_install.clone(),
            version_files: self.version_files.clone(),
        })
    }

    /// Get shell or error
    pub fn get_shell(&self) -> Result<Shell> {
        self.shell.ok_or_else(|| anyhow::anyhow!("Shell not set"))
    }
}

impl Default for WizardState {
    fn default() -> Self {
        Self::new()
    }
}

/// Print wizard header
fn print_wizard_header() {
    use owo_colors::OwoColorize;

    println!();
    println!("{}", "━".repeat(60).bright_cyan());
    crate::output::print_header();
    println!("{}", "━".repeat(60).bright_cyan());
    println!();
    println!(
        "  {} {}",
        "👋".bright_cyan(),
        "Welcome! Let's set up xvn for your environment.".bold()
    );
    println!();
    println!("  {}", "This wizard will guide you through:".dimmed());
    println!("    {} Shell detection and integration", "•".bright_cyan());
    println!("    {} Version manager selection", "•".bright_cyan());
    println!("    {} Installation preferences", "•".bright_cyan());
    println!("    {} Version file configuration", "•".bright_cyan());
    println!();
    println!(
        "  {} {}",
        "ℹ".blue(),
        "Press Ctrl+C at any time to cancel.".dimmed()
    );
    println!();
    println!("{}", "━".repeat(60).bright_cyan());
    println!();
}

/// Print success message after setup
fn print_success_message(summary: &ConfigSummary) -> Result<()> {
    use owo_colors::OwoColorize;

    println!();
    println!("{}", "━".repeat(60).bright_cyan());
    println!();
    println!(
        "  {} {}",
        "✨".bright_green(),
        "Setup complete!".bright_green().bold()
    );
    println!();
    println!("{}", "━".repeat(60).bright_cyan());
    println!();

    println!("  {}", "📋 Configuration Summary:".cyan().bold());
    println!(
        "    {} {}",
        "Shell:".dimmed(),
        summary.shell.name().bright_white()
    );
    println!(
        "    {} {}",
        "Profile:".dimmed(),
        summary.profile_path.display().to_string().bright_white()
    );
    println!(
        "    {} {}",
        "Config:".dimmed(),
        summary.config_path.display().to_string().bright_white()
    );
    println!();

    println!("  {}", "🚀 Next Steps:".cyan().bold());
    println!();
    println!(
        "    {} {}",
        "1.".bright_cyan(),
        "Restart your shell, or run:".dimmed()
    );
    println!(
        "       {}",
        format!("source {}", summary.profile_path.display()).bright_yellow()
    );
    println!();
    println!(
        "    {} {}",
        "2.".bright_cyan(),
        "Navigate to a project with a .nvmrc file".dimmed()
    );
    println!();
    println!(
        "    {} {}",
        "3.".bright_cyan(),
        "xvn will automatically activate the correct Node.js version!".dimmed()
    );
    println!();

    println!("  {}", "💡 Useful Commands:".cyan().bold());
    println!(
        "    {} {}",
        "xvn status".bright_yellow().bold(),
        "     Show current configuration".dimmed()
    );
    println!(
        "    {} {}",
        "xvn activate".bright_yellow().bold(),
        "   Manually activate for a directory".dimmed()
    );
    println!(
        "    {} {}",
        "xvn init".bright_yellow().bold(),
        "       Re-run this wizard to modify config".dimmed()
    );
    println!();
    println!("{}", "━".repeat(60).bright_cyan());
    println!();

    Ok(())
}

/// Generate config file content with comments
fn generate_config(config: &Config) -> String {
    use chrono::Local;

    let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");

    let auto_install_str = match config.auto_install {
        AutoInstallMode::Prompt => "prompt",
        AutoInstallMode::Always => "always",
        AutoInstallMode::Never => "never",
    };

    format!(
        r#"# xvn configuration file
# Generated by: xvn init
# Last modified: {}
#
# To modify this configuration, run: xvn init

# Version manager priority order
# Available: nvm, fnm, n, asdf, volta
plugins:
{}

# Auto-install behavior when version not found
# Options: prompt (ask each time), always (install automatically), never (error)
auto_install: {}

# Version files to search for (in priority order)
version_files:
{}
"#,
        timestamp,
        config
            .plugins
            .iter()
            .map(|p| format!("  - {p}"))
            .collect::<Vec<_>>()
            .join("\n"),
        auto_install_str,
        config
            .version_files
            .iter()
            .map(|f| format!("  - {f}"))
            .collect::<Vec<_>>()
            .join("\n")
    )
}

/// Write configuration to file
fn write_config(config: &Config, path: &std::path::Path, force: bool) -> Result<()> {
    use inquire::Confirm;
    use std::fs;

    // Check if config exists
    if path.exists() && !force {
        let overwrite = Confirm::new("Configuration file already exists. Overwrite?")
            .with_default(false)
            .with_help_message("Use --force to skip this prompt")
            .prompt()?;

        if !overwrite {
            anyhow::bail!("Config write cancelled - existing file preserved");
        }
    }

    // Validate config
    crate::init::validation::validate_config(config)?;

    // Generate YAML content
    let content = generate_config(config);

    // Write to file
    fs::write(path, content).context("Failed to write configuration file")?;

    log::info!("Config written to: {}", path.display());
    Ok(())
}

/// Run the interactive wizard
pub fn run_interactive_wizard(force: bool) -> Result<()> {
    // Print header
    print_wizard_header();

    // Initialize state
    let mut state = WizardState::new();

    // Step 1: Shell selection
    let shell = prompts::prompt_shell()?;
    state.shell = Some(shell);
    println!();

    // Step 2: Plugin selection
    let plugins = prompts::prompt_plugins()?;
    state.plugins = plugins;
    println!();

    // Step 3: Auto-install mode
    let auto_install = prompts::prompt_auto_install()?;
    state.auto_install = auto_install;
    println!();

    // Step 4: Version files
    let version_files = prompts::prompt_version_files()?;
    state.version_files = version_files;
    println!();

    // Step 5: Review and confirm
    let profile_path = get_profile_path(&state.get_shell()?)?;
    let config_path = home_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not determine home directory"))?
        .join(".xvnrc");

    let summary = ConfigSummary {
        shell: state.get_shell()?,
        profile_path,
        plugins: state.plugins.clone(),
        auto_install: state.auto_install.clone(),
        version_files: state.version_files.clone(),
        config_path: config_path.clone(),
    };

    let confirmed = prompts::prompt_confirm_config(&summary)?;
    if !confirmed {
        output::warning("Setup cancelled");
        return Ok(());
    }
    println!();

    // Generate and write config
    let config = state.to_config()?;
    write_config(&config, &config_path, force)?;
    output::success("Configuration saved!");

    // Install shell integration
    let installer = crate::setup::SetupInstaller::new()?;
    installer.install()?;
    output::success("Shell integration installed!");

    // Print success message
    print_success_message(&summary)?;

    Ok(())
}

/// Run quick setup with auto-detection and defaults
pub fn run_quick_setup(force: bool) -> Result<()> {
    println!();
    output::print_header();
    output::info("Running quick setup with defaults...");
    println!();

    // Auto-detect shell
    let shell = detect_shell()?;
    output::info(&format!("Detected shell: {}", shell.name()));

    // Auto-detect version managers
    let detected = detect_version_managers();
    let plugins: Vec<String> = detected.iter().map(|m| m.name.clone()).collect();

    if plugins.is_empty() {
        output::warning("No version managers detected");
        output::info("You'll need to install nvm, fnm, or n manually");
    } else {
        output::info(&format!("Detected managers: {}", plugins.join(", ")));
    }

    // Use defaults
    let auto_install = AutoInstallMode::Prompt;
    let version_files = vec![".nvmrc".to_string(), ".node-version".to_string()];

    output::info("Using defaults:");
    output::info("  • Auto-install: prompt");
    output::info("  • Version files: .nvmrc, .node-version");
    println!();

    // Create state
    let state = WizardState {
        shell: Some(shell),
        plugins,
        auto_install,
        version_files,
    };

    // Generate config
    let config = state.to_config()?;
    let config_path = home_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not determine home directory"))?
        .join(".xvnrc");

    write_config(&config, &config_path, force)?;
    output::success("Configuration saved!");

    // Install shell integration
    let installer = crate::setup::SetupInstaller::new()?;
    installer.install()?;
    output::success("Shell integration installed!");

    // Print summary
    let profile_path = get_profile_path(&shell)?;
    let summary = ConfigSummary {
        shell,
        profile_path,
        plugins: state.plugins.clone(),
        auto_install: state.auto_install.clone(),
        version_files: state.version_files.clone(),
        config_path,
    };

    print_success_message(&summary)?;

    Ok(())
}

/// Run non-interactive setup for CI/automation
pub fn run_non_interactive(force: bool) -> Result<()> {
    // Non-interactive is the same as quick mode
    // but with explicit logging for CI

    eprintln!("xvn: Running in non-interactive mode");

    run_quick_setup(force)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wizard_state_defaults() {
        let state = WizardState::new();
        assert_eq!(state.plugins.len(), 0);
        assert!(matches!(state.auto_install, AutoInstallMode::Prompt));
        assert_eq!(state.version_files.len(), 2);
    }

    #[test]
    fn test_to_config() {
        let mut state = WizardState::new();
        state.shell = Some(Shell::Zsh);
        state.plugins = vec!["nvm".to_string()];

        let config = state.to_config().unwrap();
        assert_eq!(config.plugins, vec!["nvm"]);
    }

    #[test]
    fn test_generate_config_format() {
        let config = Config {
            plugins: vec!["nvm".to_string(), "fnm".to_string()],
            auto_install: AutoInstallMode::Prompt,
            version_files: vec![".nvmrc".to_string()],
        };
        let yaml = generate_config(&config);

        // Verify YAML structure
        assert!(yaml.contains("plugins:"));
        assert!(yaml.contains("  - nvm"));
        assert!(yaml.contains("  - fnm"));
        assert!(yaml.contains("auto_install: prompt"));

        // Verify it can be parsed back
        let parsed: serde_yaml::Value = serde_yaml::from_str(&yaml).unwrap();
        assert!(parsed["plugins"].is_sequence());
    }
}
